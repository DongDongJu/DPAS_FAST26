<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LHP I/O Completion Emulator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px 20px;
            background: #f5f6f8;
            color: #1a1a2e;
        }
        h1 { text-align: center; font-size: 1.7rem; margin-bottom: 4px; color: #16213e; }
        .subtitle { text-align: center; color: #555; font-size: 0.95rem; margin-bottom: 20px; }

        /* Controls */
        .controls {
            background: #fff; border-radius: 10px; padding: 20px 24px;
            margin-bottom: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: grid; grid-template-columns: 1fr 1fr; gap: 16px;
        }
        .ctrl-section h3 {
            font-size: 0.9rem; color: #1565c0; margin-bottom: 10px;
            border-bottom: 2px solid #e3f2fd; padding-bottom: 4px;
        }
        .ctrl-row {
            display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
            font-size: 0.85rem;
        }
        .ctrl-row label { min-width: 130px; font-weight: 500; }
        .ctrl-row input[type="number"] {
            width: 90px; padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 0.85rem;
        }
        .ctrl-row input[type="checkbox"] { width: 16px; height: 16px; }
        .ctrl-row .val { min-width: 50px; color: #1565c0; font-weight: 600; font-size: 0.85rem; }
        .unit { font-size: 0.82rem; color: #777; }
        select {
            padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 0.85rem; background: #fff;
        }
        .btn-row { display: flex; gap: 8px; margin-top: 8px; }
        button {
            padding: 8px 20px; border: none; border-radius: 6px; cursor: pointer;
            font-size: 0.85rem; font-weight: 600; transition: all 0.15s;
        }
        .btn-primary { background: #1565c0; color: #fff; }
        .btn-primary:hover { background: #0d47a1; }
        .btn-secondary { background: #e0e0e0; color: #333; }
        .btn-secondary:hover { background: #bdbdbd; }

        /* Charts */
        .chart-wrapper {
            background: #fff; border-radius: 10px; padding: 20px;
            margin-bottom: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .chart-wrapper h2 { font-size: 1.1rem; margin-bottom: 4px; color: #16213e; }
        .chart-subtitle { font-size: 0.82rem; color: #777; margin-bottom: 8px; }
        .chart-container { position: relative; height: 300px; }

        /* Stats */
        .stats-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px;
            margin-bottom: 16px;
        }
        .stat-card {
            background: #fff; border-radius: 8px; padding: 14px 12px;
            text-align: center; box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }
        .stat-card .label { font-size: 0.75rem; color: #777; margin-bottom: 4px; }
        .stat-card .value { font-size: 1.3rem; font-weight: 700; color: #16213e; }
        .stat-card .unit { font-size: 0.7rem; color: #999; }
        .stat-card.highlight { border: 2px solid #c62828; }
        .stat-card.highlight .value { color: #c62828; }

        /* Step display */
        .step-panel {
            background: #263238; color: #eceff1; border-radius: 10px;
            padding: 16px 20px; margin-bottom: 16px; font-family: 'Courier New', monospace;
            font-size: 0.8rem; line-height: 1.7; max-height: 200px; overflow-y: auto;
        }
        .step-panel .io-under { color: #81c784; }
        .step-panel .io-over { color: #ef9a9a; }
        .step-panel .io-header { color: #80cbc4; font-weight: bold; }
        .step-panel .epoch-hdr { color: #ffcc80; font-weight: bold; }

        /* Upload */
        .upload-row {
            display: flex; align-items: center; gap: 8px; margin-bottom: 8px;
        }
        .upload-row label { min-width: 130px; font-weight: 500; font-size: 0.85rem; }
        .file-label {
            display: inline-block; padding: 4px 12px; background: #e3f2fd;
            border: 1px solid #90caf9; border-radius: 4px; cursor: pointer;
            font-size: 0.82rem; color: #1565c0; font-weight: 500;
        }
        .file-label:hover { background: #bbdefb; }
        .file-name { font-size: 0.8rem; color: #777; margin-left: 4px; max-width: 130px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* Model box */
        .model-box {
            background: #fff; border-radius: 10px; padding: 16px 24px;
            margin-bottom: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            font-size: 0.82rem; line-height: 1.7;
        }
        .model-box h3 { font-size: 0.95rem; color: #16213e; margin-bottom: 8px; }
        .model-box pre {
            background: #263238; color: #eceff1; padding: 12px 16px;
            border-radius: 6px; overflow-x: auto; font-size: 0.78rem; line-height: 1.6;
        }
        .model-box .key-point { color: #c62828; font-weight: 600; }

        /* Playback */
        .playback {
            display: flex; align-items: center; gap: 12px; margin-bottom: 16px;
            background: #fff; border-radius: 10px; padding: 12px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .playback input[type="range"] { flex: 1; }
        .playback .info { font-size: 0.85rem; color: #555; min-width: 200px; }

        /* Attenuation custom row */
        #custom-atten-row { display: none; }
    </style>
</head>
<body>
    <h1>LHP: I/O Completion Emulator</h1>
    <p class="subtitle">Epoch-based sleep prediction &mdash; measured_io feedback creates positive feedback loop &rarr; latency shelving</p>

    <!-- I/O Completion Model -->
    <div class="model-box">
        <h3>I/O Completion Model &amp; LHP Algorithm</h3>
<pre>Each I/O:
  wake_time = sleep_duration + cs_overhead (<span style="color:#80cbc4">&delta;</span>)

  <span style="color:#81c784">UNDER</span> (device_time &gt; wake_time):  app wakes before device completes
      app_latency  = device_time      <span style="color:#aaa">(correct)</span>
      measured_io  = device_time

  <span style="color:#ef9a9a">OVER</span>  (device_time &le; wake_time):  device finishes while app sleeps
      app_latency  = wake_time        <span style="color:#aaa">(wasted time)</span>
      measured_io  = wake_time        <span style="color:#aaa">(inflated!)</span>

LHP update (each epoch):
  sleep_next = attenuation &times; mean(measured_io)

<span class="key-point">Problem: measured_io includes inflated oversleep values
  &rarr; next epoch&#39;s sleep is too high &rarr; more oversleep &rarr; even more inflation
  &rarr; positive feedback loop &rarr; LATENCY SHELVING</span></pre>
    </div>

    <!-- Controls -->
    <div class="controls">
        <div class="ctrl-section">
            <h3>LHP Parameters</h3>
            <div class="ctrl-row">
                <label>Attenuation:</label>
                <select id="param-atten-mode" onchange="onAttenModeChange()">
                    <option value="50" selected>50%</option>
                    <option value="75">75%</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
            <div class="ctrl-row" id="custom-atten-row">
                <label>Custom rate:</label>
                <input type="number" id="param-atten-custom" value="60" step="1" min="1" max="99">
                <span class="unit">%</span>
            </div>
            <div class="ctrl-row">
                <label>Epoch duration:</label>
                <input type="number" id="param-epoch-dur" value="100" step="10" min="0.1" max="10000">
                <span class="unit">ms</span>
                <input type="checkbox" id="param-epoch-auto" checked onchange="onEpochAutoChange()">
                <span class="unit">Auto</span>
            </div>
            <div class="ctrl-row">
                <label>CS overhead (&delta;):</label>
                <input type="number" id="param-cs" value="2" step="0.5" min="0" max="50">
                <span class="unit">&mu;s</span>
            </div>
            <div class="ctrl-row">
                <label>Initial sleep:</label>
                <input type="number" id="param-init" value="4" step="1" min="0.01" max="200">
                <span class="unit">&mu;s</span>
            </div>
        </div>
        <div class="ctrl-section">
            <h3>Trace Input</h3>
            <div class="ctrl-row">
                <label>Preset:</label>
                <select id="trace-select" onchange="onTraceSelectChange()">
                    <option value="step" selected>Step: 30 &rarr; 100 &rarr; 30 &mu;s</option>
                    <option value="constant30">Constant 30 &mu;s</option>
                    <option value="ramp">Ramp: 10 &rarr; 200 &mu;s</option>
                    <option value="noisy30">Noisy ~30 &mu;s (&sigma;=3)</option>
                    <option value="bimodal">Bimodal: 30/150 &mu;s</option>
                    <option value="zssd">ZSSD Trace (from xlsx)</option>
                    <option value="custom">Custom (upload file)</option>
                </select>
            </div>
            <div class="ctrl-row" id="dur-row">
                <label>Target duration:</label>
                <input type="number" id="param-dur" value="2000" step="100" min="10" max="60000">
                <span class="unit">ms</span>
            </div>
            <div class="upload-row" id="upload-row" style="display:none">
                <label>Upload trace:</label>
                <label class="file-label" for="file-input">Choose file</label>
                <input type="file" id="file-input" accept=".txt,.csv,.dat,.log" style="display:none" onchange="handleFileUpload(this)">
                <span class="file-name" id="file-name">No file</span>
            </div>
            <div class="btn-row">
                <button class="btn-primary" onclick="runEmulation()">Run Emulation</button>
                <button class="btn-secondary" onclick="resetDefaults()">Reset Defaults</button>
            </div>
        </div>
    </div>

    <!-- Stats -->
    <div class="stats-grid">
        <div class="stat-card">
            <div class="label">Avg App Latency</div>
            <div class="value" id="stat-app-lat">-</div>
            <div class="unit">&mu;s</div>
        </div>
        <div class="stat-card">
            <div class="label">Avg Device Time</div>
            <div class="value" id="stat-dev-lat">-</div>
            <div class="unit">&mu;s</div>
        </div>
        <div class="stat-card" id="stat-overhead-card">
            <div class="label">Latency Overhead</div>
            <div class="value" id="stat-overhead">-</div>
            <div class="unit">%</div>
        </div>
        <div class="stat-card">
            <div class="label">OVER Count</div>
            <div class="value" id="stat-over-cnt">-</div>
            <div class="unit">I/Os</div>
        </div>
        <div class="stat-card">
            <div class="label">Final Sleep</div>
            <div class="value" id="stat-final">-</div>
            <div class="unit">&mu;s</div>
        </div>
    </div>

    <!-- Playback scrubber -->
    <div class="playback">
        <button class="btn-secondary" id="btn-play" onclick="togglePlay()">&#9654; Play</button>
        <input type="range" id="scrubber" min="0" max="100" value="0" oninput="scrubTo(this.value)">
        <div class="info" id="scrub-info">I/O 0 / 0 | 0.0 / 0.0 ms</div>
    </div>

    <!-- Main Chart: all 4 signals -->
    <div class="chart-wrapper">
        <h2>I/O Completion Emulation</h2>
        <p class="chart-subtitle">
            <span style="color:#f9a825">&#9644; Genuine Device Latency</span> &nbsp;
            <span style="color:#4db6ac">- - Requested Sleep</span> &nbsp;
            <span style="color:#00796b">&#9644; Actual Sleep (sleep + &delta;)</span> &nbsp;
            <span style="color:#1565c0">- - App-Perceived I/O Latency</span> &nbsp;
            <span style="color:#e53935">&#9632; Oversleep Penalty</span>
        </p>
        <div class="chart-container"><canvas id="mainChart"></canvas></div>
    </div>

    <!-- Step log -->
    <div class="step-panel" id="stepLog">
        <span class="io-header">Run emulation to see step-by-step log...</span>
    </div>

<script>
// ===== Trace Data =====
const ZSSD_TRACE = [31.201,31.019,30.447,31.701,34.824,30.089,30.267,31.216,30.3,31.257,30.272,30.178,30.205,31.734,31.712,31.74,31.702,30.38,30.215,31.725,30.041,30.318,30.924,30.601,31.179,30.292,29.946,33.678,32.101,31.137,32.177,31.977,30.13,30.718,30.289,30.115,31.135,31.38,31.38,30.166,31.545,30.451,30.572,30.604,34.61,39.845,31.129,30.304,30.107,30.594,31.641,30.545,30.02,30.159,30.319,30.064,34.788,32.124,34.512,29.997,31.359,31.514,34.768,31.353,30.98,31.756,30.263,31.164,31.541,31.015,30.96,30.226,31.183,31.232,30.334,31.271,30.426,29.975,31.083,31.271,30.461,30.687,31.31,30.662,31.554,30.001,30.944,30.433,30.204,49.127,45.964,30.249,38.498,34.791,30.991,30.005,30.24,30.001,30.133,30.098,31.364,30.011,30.966,30.851,31.124,30.05,30.12,32.889,31.045,37.763,33.353,30.953,32.784,30.155,31.293,30.469,32.096,30.104,30.792,32.848,30.521,30.287,30.779,31.804,31.408,31.234,30.036,31.093,32.658,31.138,30.502,31.219,50.757,39.215,32.921,36.697,38.387,31.987,30.985,30.5,31.754,30.327,30.267,35.903,32.75,30.045,36.65,31.641,30.4,30.212,30.133,31.715,30.953,31.31,30.341,31.478,30.673,30.008,35.47,34.736,31.12,33.006,31.275,30.552,30.124,30.646,29.946,32.837,30.45,30.224,32.603,30.237,29.907,30.713,29.874,30.407,30.184,30.159,31.225,31.354,30.058,30.302,30.216,30.032,30.306,30.881,37.802,31.979,36.108,31.414,30.817,31.439,30.32,30.394,31.065,32.97,35.884,43.301,37.847,30.449,36.345,32.701,35.837,42.498,37.568,44.378,42.924,44.817,37.85,43.491,73.632,107.174,114.26,115.675,78.327,81.914,69.069,60.866,96.153,110.312,94.678,120.113,66.53,75.342,113.526,101.923,59.405,50.794,79.513,96.83,108.102,24.782,67.491,45.353,117.56,107.174,90.882,127.067,45.345,57.09,42.907,82.546,121.052,46.131,34.602,46.757,56.012,58.022,28.307,45.559,48.555,40.656,19.071,51.586,48.424,35.256,28.697,27.409,32.592,36.176,50.442,35.085,38.814,34.717,26.72,27.185,27.68,33.197,29.017,34.65,41.341,27.41,28.409,36.927,74.673,63.425,25.784,32.227,28.623,67.105,74.836,42.253,44.636,31.603,35.088,33.497,36.559,39.598,37.242,37.335,38.092,121.822,25.95,31.753,40.901,117.56,121.052,24.243,34.373,105.324,27.105,35.954,40.029,45.85,39.193,125.58,83.053,81.202,36.033,69.775,71.498,115.904,120.104,97.9,128.509,80.358,80.401,54.622,54.579,148.301,113.275,117.576,150.412,141.245,78.555,103.793,124.126,52.267,43.524,124.648,130.673,113.822,82.949,99.387,122.185,85.583,42.196,64.62,55.544,38.449,36.013,55.059,95.417,77.842,30.284,33.497,61.175,26.797,33.036,52.131,28.079,30.455,26.428,24.881,37.478,31.372,32.2,24.05,24.171,35.997,28.601,30.564,30.086,25.373,28.869,26.546,32.232,33.932,29.247,32.21,26.974,30.392,36.482,33.403,37.658,43.967,44.382,47.321,39.75,33.769,26.228,26.641,26.813,35.802,43.487,50.539,49.479,36.291,50.827,43.792,54.081,46.099,36.446,38.693,37.355,35.068,37.235,32.125,37.579,36.764,46.065,39.597,28.485,29.181,52.384,59.605,34.895,34.787,42.898,30.696,42.508,67.01,30.044,28.743,36.988,31.851,27.838,27.597,44.229,35.393,42.337,28.754,29.076,29.358,30,43.178,33.136,41.526,42.436,39.789,36.206,27.417,51.699,27.302,27.699,30.034,28.741,43.292,27.985,35.773,30.357,31.991,34.642,35.285,28.41,37.275,44.385,28.397,44.591,51.121,33.1,27.943,36.335,40.566,32.675,28.424,28.575,28.271,40.792,36.785,36.105,38.662,39.048,28.663,28.835,27.626,27.403,28.48,28.393,27.365,28.83,28.332,27.453,27.341,27.663,27.475,28.362,28.516,27.445,27.423,27.291,28.426,28.485,28.486,28.378,27.629,27.862,27.325,27.415,28.329,36.066,34.478,40.207,27.56,28.778,28.363,31.881,29.225,28.737,28.249,28.27,27.477,29.808,28.543,40.117,31.757,29.738,30.411,30.989,30.711,31.535,28.605,29.274,31.643,29.418,30.881,44.21,30.739,30.492,30.226,29.404,30.418,30.282,6.242,24.423,31.635,30.151,30.159,32.027,40.914,31.894,30.294,30.704,31.281,29.947,30.394,31.069,30.166,29.724,30.705,42.314,24.11,30.835,29.19,31.821,29.42,30.012,31.65,30.409,29.433,30.998,29.633,41.811,30.334,29.741,32.067,29.625,29.035,31.726,28.885,30.318,30.616,29.834,32.338,58.758,55.47,29.736,31.662,30.454,29.884,30.709,30.551,30.286,29.94,30.394,40.979,29.163,30.558,30.874,29.589,30.476,30.221,29.351,30.719,30.777,28.927,34.336,29.813,30.596,32.033,26.849,30.373,31.631,29.638,29.879,30.621,42.185,30.524,29.596,30.362,32.456,29.637,30.766,31.826,30.397,30.762,31.49,41.281,31.077,30.562,30.563,6.41,28.315,29.066,6.318,24.279,29.662,29.344,28.661,30.633,30.613,35.295,31.347,30.625,31.576,28.945,30.178,31.441,30.076,29.646,30.135,30.016,30.302,38.956,29.295,32.09,29.8,30.868,30.891,30.357,29.798,29.866,29.919,28.88,30.792,30.45,30.617,30.289,29.458,31.444,30.231,29.992,32.49,29.993,40.357,25.314,27.319,32.105,27.78,29.015,31.708,28.71,6.325,24.028,32.073,28.722,30.146,44.446,30.719,30.808,28.282,30.572,31.038,29.972,30.225,30.875,29.615,30.611,34.341,30.81,30.103,30.731,28.897,32.135,30.612,29.968,31.02,30.211,42.587,28.437,29.603,29.97,28.482,29.482,30.961,30.697,28.552,32.128,30.46,42.357,58.854,6.302,25.607,30.213,29.245,31.346,30.332,29.888,30.985,29.947,30.256,40.257,30.095,30.075,30.665,30.173,31.682,29.57,30.41,31.101,28.555,30.614,41.44,29.454,31.063,29.902,30.039,30.978,30.925,29.475,29.128,30.821,30.482,40.777,29.548,31.143,29.463,29.009,31.99,29.167,30.406,30.19,30.032,30.519,41.391,30.279,30.945,30.516,29.323,32.374,30.108,51.942,49.145,53.706,51.049,60.845,63.296,61.279,76.492,69.787,67.255,66.562,73.941,74.723,55.142,67.257,77.529,70.138,62.25,68.096,67.313,72.954,64.558,66.355,77.365,70.694,67.111,66.061,65.404,99.417,74.721,130.763,133.491,135.371,130.233,151.609,153.703,129.778,153.299,151.456,131.75,158.264,155.011,138.001,156.843,161.661,160.558,178.812,166.939,162.863,173.77,173.381,189.228,173.911,181.896,184.53,178.956,176.058,176.26,193.002,176.349,183.459,179.744,144.473,173.463,180.274,180.587,187.2,176.339,167.134,185.113,175.782,172.395,158.439,184.304,183.207,159.927,182.004,179.839,187.831,181.622,185.824,180.983,173.02,178.786,183.4,190.157,186.026,178.695,181.653,188.997,186.958,186.443,189.824,176.58,184.295,16.118,19.86,188.964,93.658,18.872,67.758,186.992,89.65,90.927,189.999,95.698,24.041,15.149,19.465,15.08,29.098,209.314,30.612,26.946,29.009,17.695,11.752,38.98,181.473,17.18,89.892,114.18,50.152,55.796,188.229,71.917,42.126,186.861,132.305,35.763,11.13,19.023,34.472,14.658,193.641,41.799,37.457,17.685,22.392,39.32,185.614,42.677,34.196,28.433,11.3,28.49,22.264,35.788,16.153,14.092,183.979,155.791,43.326,16.51,46.458,181.936,51.039,22.917,157.166,191.997,97.506,43.9,25.349,37.147,220.759,14.393,12.818,39.737,48.08,192.436,125.167,17.239,34.109,36.481,11.674,200.045,40.76,47.096,42.511,15.362,20.516,188.93,27.416,15.363,148.904,194.783,46.721,185.152,187.299,29.502,23.139,20.095,30.023,191.504,143.588,22.001,213.389,162.703,33.001,43.168,193.194,33.057,147.34,192.037,45.22,29.459,186.08,185.36,182.033,174.402,39.627,33.102,29.868,13.152,190.804,35.463,185.641,164.837,27.622,37.595,189.979,133.368,38.361,21.111,35.42,35.324,201.95,129.729,13.879,20.026,32.213,190.738,53.219,55.706,194.967,160.015,21.431,184.964,161.995,42.797,27.665,185.828,41.65,39.228,59.578,8.949,34,34.913,29.521];

// ===== LTTB Downsampling =====
const DOWNSAMPLE_THRESHOLD = 3000;
const DOWNSAMPLE_TARGET = 2000;

function lttbSelectIndices(xArr, yArr, target) {
    const n = xArr.length;
    if (n <= target) return Array.from({length: n}, (_, i) => i);

    const indices = [0];
    const bucketSize = (n - 2) / (target - 2);

    let prevIdx = 0;
    for (let b = 1; b < target - 1; b++) {
        const bucketStart = Math.floor((b - 1) * bucketSize) + 1;
        const bucketEnd   = Math.min(Math.floor(b * bucketSize) + 1, n - 1);
        const nextStart   = Math.min(Math.floor((b) * bucketSize) + 1, n - 1);
        const nextEnd     = Math.min(Math.floor((b + 1) * bucketSize) + 1, n - 1);

        let avgX = 0, avgY = 0, cnt = 0;
        for (let j = nextStart; j < nextEnd; j++) { avgX += xArr[j]; avgY += yArr[j]; cnt++; }
        if (cnt === 0) { avgX = xArr[nextStart]; avgY = yArr[nextStart]; cnt = 1; }
        avgX /= cnt; avgY /= cnt;

        let maxArea = -1, bestIdx = bucketStart;
        const px = xArr[prevIdx], py = yArr[prevIdx];
        for (let j = bucketStart; j < bucketEnd; j++) {
            const area = Math.abs((px - avgX) * (yArr[j] - py) - (px - xArr[j]) * (avgY - py));
            if (area > maxArea) { maxArea = area; bestIdx = j; }
        }
        indices.push(bestIdx);
        prevIdx = bestIdx;
    }
    indices.push(n - 1);
    return indices;
}

// ===== Trace Generation =====
function estimateAvgDeviceTime(type) {
    switch(type) {
        case 'constant30': return 30;
        case 'step': return 30 * 0.4 + 100 * 0.2 + 30 * 0.4;
        case 'ramp': return 105;
        case 'noisy30': return 30;
        case 'bimodal': return 0.7 * 30 + 0.3 * 150;
        default: return 30;
    }
}

function generateTrace(type, targetDurationMs) {
    const t = [];
    if (type === 'zssd') {
        return ZSSD_TRACE.slice();
    }
    if (type === 'custom') {
        return customTrace.length > 0 ? customTrace.slice() : [30];
    }

    const targetUs = targetDurationMs * 1000;
    const avgDev = estimateAvgDeviceTime(type);
    const len = Math.max(100, Math.round(targetUs / avgDev));

    switch(type) {
        case 'constant30':
            for (let i = 0; i < len; i++) t.push(30);
            return t;
        case 'step':
            for (let i = 0; i < len; i++) {
                if (i < len * 0.4) t.push(30);
                else if (i < len * 0.6) t.push(100);
                else t.push(30);
            }
            return t;
        case 'ramp':
            for (let i = 0; i < len; i++) t.push(10 + (190 * i / (len - 1)));
            return t;
        case 'noisy30':
            for (let i = 0; i < len; i++) {
                const u1 = Math.random(), u2 = Math.random();
                const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                t.push(Math.max(5, 30 + z * 3));
            }
            return t;
        case 'bimodal':
            for (let i = 0; i < len; i++) t.push(Math.random() < 0.7 ? 30 : 150);
            return t;
    }
    return t;
}

// ===== Custom trace upload =====
let customTrace = [];

function onTraceSelectChange() {
    const sel = document.getElementById('trace-select').value;
    document.getElementById('upload-row').style.display = sel === 'custom' ? 'flex' : 'none';
    document.getElementById('dur-row').style.display = (sel === 'zssd' || sel === 'custom') ? 'none' : 'flex';
}

function onAttenModeChange() {
    const mode = document.getElementById('param-atten-mode').value;
    document.getElementById('custom-atten-row').style.display = mode === 'custom' ? 'flex' : 'none';
}

function onEpochAutoChange() {
    const auto = document.getElementById('param-epoch-auto').checked;
    document.getElementById('param-epoch-dur').disabled = auto;
}

function handleFileUpload(input) {
    const file = input.files[0];
    if (!file) return;
    document.getElementById('file-name').textContent = file.name;
    const reader = new FileReader();
    reader.onload = function(e) {
        const text = e.target.result;
        customTrace = [];
        for (const line of text.split(/\r?\n/)) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            const tok = trimmed.split(/[,\t;]/)[0].trim();
            const val = parseFloat(tok);
            if (!isNaN(val) && val > 0) customTrace.push(val);
        }
        if (customTrace.length === 0) {
            alert('No valid numeric values found in file.');
            return;
        }
        document.getElementById('file-name').textContent = file.name + ' (' + customTrace.length + ' I/Os)';
        runEmulation();
    };
    reader.readAsText(file);
}

function getAttenuation() {
    const mode = document.getElementById('param-atten-mode').value;
    if (mode === 'custom') return parseFloat(document.getElementById('param-atten-custom').value) / 100;
    return parseFloat(mode) / 100;
}

// ===== LHP I/O Completion Emulation (time-based epoch) =====
function emulate(trace, attenuation, epochDurationMs, csOverhead, initSleep) {
    const n = trace.length;
    const epochDurationUs = epochDurationMs * 1000;
    const result = {
        sleepDur: [],
        wakeTime: [],
        appLatency: [],
        measuredIO: [],
        sr: [],
        epochNum: [],
        epochSleeps: [],
    };

    let currentSleep = initSleep;
    let epochIdx = 0;
    let epochMeasured = [];
    let epochCumTime_us = 0;

    for (let i = 0; i < n; i++) {
        const wake = currentSleep + csOverhead;
        const deviceTime = trace[i];

        let appLat, measIO;
        if (deviceTime > wake) {
            appLat = deviceTime;
            measIO = deviceTime;
        } else {
            appLat = wake;
            measIO = wake;
        }

        const sr_curr = deviceTime > wake ? 1 : 0;

        result.sleepDur.push(currentSleep);
        result.wakeTime.push(wake);
        result.appLatency.push(appLat);
        result.measuredIO.push(measIO);
        result.sr.push(sr_curr);
        result.epochNum.push(epochIdx);

        epochMeasured.push(measIO);
        epochCumTime_us += appLat;

        // Time-based epoch boundary
        if (epochCumTime_us >= epochDurationUs) {
            const meanMeasured = epochMeasured.reduce((a, b) => a + b, 0) / epochMeasured.length;
            currentSleep = attenuation * meanMeasured;
            result.epochSleeps.push({ epoch: epochIdx, sleep: currentSleep, meanMeasured: meanMeasured, ioCount: epochMeasured.length });
            epochIdx++;
            epochMeasured = [];
            epochCumTime_us = 0;
        }
    }
    // Final partial epoch
    if (epochMeasured.length > 0) {
        const meanMeasured = epochMeasured.reduce((a, b) => a + b, 0) / epochMeasured.length;
        result.epochSleeps.push({ epoch: epochIdx, sleep: attenuation * meanMeasured, meanMeasured: meanMeasured, ioCount: epochMeasured.length });
    }

    return result;
}

// ===== Charts =====
let mainChart = null;
let simResult = null;
let currentTrace = null;
let cumTime = null;
let totalTime_ms = 0;
let dsXY = null;
let dsIndices = null;
let playing = false;
let playTimer = null;
let PLAY_STEP = 3;
const PLAY_INTERVAL = 30;

function createCharts() {
    const scatterLine = { showLine: true, pointRadius: 0 };

    mainChart = new Chart(document.getElementById('mainChart').getContext('2d'), {
        type: 'scatter',
        data: {
            datasets: [
                {
                    label: 'Genuine Device Latency',
                    data: [],
                    borderColor: '#f9a825',
                    borderWidth: 1.5, fill: false, order: 4,
                    ...scatterLine
                },
                {
                    label: 'Requested Sleep',
                    data: [],
                    borderColor: '#4db6ac',
                    borderWidth: 1, borderDash: [5, 3], fill: false, order: 3,
                    ...scatterLine
                },
                {
                    label: 'Actual Sleep (sleep + \u03B4)',
                    data: [],
                    borderColor: '#00796b',
                    borderWidth: 1, fill: false, order: 2,
                    ...scatterLine
                },
                {
                    label: 'App-Perceived I/O Latency',
                    data: [],
                    borderColor: '#1565c0',
                    backgroundColor: 'rgba(244,67,54,0.3)',
                    borderWidth: 1.5, borderDash: [6, 3], fill: {target: 0, above: 'rgba(244,67,54,0.3)'}, order: 1,
                    ...scatterLine
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: { mode: 'nearest', intersect: false },
            scales: {
                x: {
                    type: 'linear', min: 0, max: 1,
                    title: { display: true, text: 'Time (ms)', font: {size: 12} },
                    ticks: { maxTicksLimit: 10, font: {size: 10} }
                },
                y: {
                    min: 0,
                    title: { display: true, text: 'Time (\u03BCs)', font: {size: 12} },
                    ticks: { font: {size: 10} }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        title: items => items[0].raw.x.toFixed(2) + ' ms',
                        label: item => item.dataset.label + ': ' + item.raw.y.toFixed(2) + ' \u03BCs'
                    }
                },
            }
        }
    });
}

function buildCumTime() {
    const n = currentTrace.length;
    cumTime = new Float64Array(n);
    let sum = 0;
    for (let i = 0; i < n; i++) {
        sum += simResult.appLatency[i];
        cumTime[i] = sum / 1000;
    }
    totalTime_ms = n > 0 ? cumTime[n - 1] : 0;
}

function buildDownsampledXY() {
    const n = currentTrace.length;
    if (n > DOWNSAMPLE_THRESHOLD) {
        dsIndices = lttbSelectIndices(Array.from(cumTime), simResult.appLatency, DOWNSAMPLE_TARGET);
    } else {
        dsIndices = Array.from({length: n}, (_, i) => i);
    }
    dsXY = {
        trace:  dsIndices.map(i => ({x: cumTime[i], y: currentTrace[i]})),
        sleep:  dsIndices.map(i => ({x: cumTime[i], y: simResult.sleepDur[i]})),
        wake:   dsIndices.map(i => ({x: cumTime[i], y: simResult.wakeTime[i]})),
        appLat: dsIndices.map(i => ({x: cumTime[i], y: simResult.appLatency[i]})),
    };
}

function updateEpochAnnotations() {
    const annotations = {};
    for (let i = 0; i < currentTrace.length - 1; i++) {
        if (simResult.epochNum[i] !== simResult.epochNum[i + 1]) {
            annotations['epoch' + simResult.epochNum[i]] = {
                type: 'line',
                xMin: cumTime[i],
                xMax: cumTime[i],
                borderColor: 'rgba(0,0,0,0.12)',
                borderWidth: 1,
            };
        }
    }
    mainChart.options.plugins.annotation = { annotations };
}

function updateCharts(n) {
    if (n === undefined) n = currentTrace.length;
    if (n === 0) {
        mainChart.data.datasets[0].data = [];
        mainChart.data.datasets[1].data = [];
        mainChart.data.datasets[2].data = [];
        mainChart.data.datasets[3].data = [];
        mainChart.update('none');
        return;
    }

    const cutoffTime = cumTime[Math.min(n - 1, currentTrace.length - 1)];

    let endIdx = dsXY.trace.length;
    for (let j = 0; j < dsXY.trace.length; j++) {
        if (dsXY.trace[j].x > cutoffTime) { endIdx = j; break; }
    }

    mainChart.data.datasets[0].data = dsXY.trace.slice(0, endIdx);
    mainChart.data.datasets[1].data = dsXY.sleep.slice(0, endIdx);
    mainChart.data.datasets[2].data = dsXY.wake.slice(0, endIdx);
    mainChart.data.datasets[3].data = dsXY.appLat.slice(0, endIdx);
    mainChart.options.scales.x.min = 0;
    mainChart.options.scales.x.max = totalTime_ms;
    mainChart.update('none');
}

function updateStats(upTo) {
    const n = upTo !== undefined ? upTo : currentTrace.length;
    if (n === 0) {
        document.getElementById('stat-app-lat').textContent = '-';
        document.getElementById('stat-dev-lat').textContent = '-';
        document.getElementById('stat-overhead').textContent = '-';
        document.getElementById('stat-over-cnt').textContent = '-';
        document.getElementById('stat-final').textContent = '-';
        document.getElementById('stat-overhead-card').classList.remove('highlight');
        return;
    }

    const appSlice = simResult.appLatency.slice(0, n);
    const devSlice = currentTrace.slice(0, n);

    const sumApp = appSlice.reduce((a, b) => a + b, 0);
    const sumDev = devSlice.reduce((a, b) => a + b, 0);
    const avgApp = sumApp / n;
    const avgDev = sumDev / n;

    document.getElementById('stat-app-lat').textContent = avgApp.toFixed(2);
    document.getElementById('stat-dev-lat').textContent = avgDev.toFixed(2);

    const overhead = avgDev > 0 ? ((avgApp - avgDev) / avgDev * 100) : 0;
    document.getElementById('stat-overhead').textContent = overhead.toFixed(1);

    const card = document.getElementById('stat-overhead-card');
    if (overhead > 5) card.classList.add('highlight');
    else card.classList.remove('highlight');

    const overCount = simResult.sr.slice(0, n).filter(v => v === 0).length;
    document.getElementById('stat-over-cnt').textContent = overCount;

    document.getElementById('stat-final').textContent = simResult.sleepDur[n - 1].toFixed(2);
}

function updateStepLog(upTo) {
    const n = upTo !== undefined ? upTo : currentTrace.length;
    const log = document.getElementById('stepLog');
    const start = Math.max(0, n - 20);

    let html = '<span class="io-header">I/O#  | Device    | Wake      | AppLat    | MeasIO    | Result | Epoch | Sleep Dur</span>\n';
    let lastEpoch = -1;
    for (let i = start; i < n; i++) {
        if (simResult.epochNum[i] !== lastEpoch) {
            lastEpoch = simResult.epochNum[i];
            const es = simResult.epochSleeps.find(e => e.epoch === lastEpoch);
            if (es) {
                html += `<span class="epoch-hdr">--- Epoch ${lastEpoch}: sleep=${es.sleep.toFixed(3)}, mean_measured=${es.meanMeasured.toFixed(3)}, ${es.ioCount} I/Os ---</span>\n`;
            }
        }
        const sr = simResult.sr[i] === 1 ? 'UNDER' : 'OVER ';
        const cls = simResult.sr[i] === 1 ? 'io-under' : 'io-over';
        const line = `${String(i).padStart(5)} | ${currentTrace[i].toFixed(3).padStart(9)} | ${simResult.wakeTime[i].toFixed(3).padStart(9)} | ${simResult.appLatency[i].toFixed(3).padStart(9)} | ${simResult.measuredIO[i].toFixed(3).padStart(9)} | <span class="${cls}">${sr}</span> | ${String(simResult.epochNum[i]).padStart(5)} | ${simResult.sleepDur[i].toFixed(3)}`;
        html += line + '\n';
    }
    log.innerHTML = html;
    log.scrollTop = log.scrollHeight;
}

// ===== Run =====
function estimateTotalTimeMs(trace) {
    const sum = trace.reduce((a, b) => a + b, 0);
    return sum / 1000;
}

function runEmulation() {
    const attenuation = getAttenuation();
    const cs = parseFloat(document.getElementById('param-cs').value);
    const initSleep = parseFloat(document.getElementById('param-init').value);
    const traceType = document.getElementById('trace-select').value;
    const targetDur = parseFloat(document.getElementById('param-dur').value);

    currentTrace = generateTrace(traceType, targetDur);

    // Compute epoch duration
    const autoEpoch = document.getElementById('param-epoch-auto').checked;
    let epochDurMs;
    if (autoEpoch) {
        const estTotal = estimateTotalTimeMs(currentTrace);
        epochDurMs = estTotal / 20;
        document.getElementById('param-epoch-dur').value = epochDurMs.toFixed(1);
    } else {
        epochDurMs = parseFloat(document.getElementById('param-epoch-dur').value);
    }

    simResult = emulate(currentTrace, attenuation, epochDurMs, cs, initSleep);

    buildCumTime();
    buildDownsampledXY();
    updateEpochAnnotations();

    PLAY_STEP = Math.max(1, Math.ceil(currentTrace.length / 1000));

    const scrubber = document.getElementById('scrubber');
    scrubber.max = currentTrace.length;
    scrubber.value = 0;
    scrubTo(0);
    stopPlay();
}

function resetDefaults() {
    document.getElementById('param-atten-mode').value = '50';
    document.getElementById('param-atten-custom').value = '60';
    document.getElementById('param-epoch-dur').value = '100';
    document.getElementById('param-epoch-auto').checked = true;
    document.getElementById('param-cs').value = '2';
    document.getElementById('param-init').value = '4';
    document.getElementById('trace-select').value = 'step';
    document.getElementById('param-dur').value = '2000';
    onTraceSelectChange();
    onAttenModeChange();
    onEpochAutoChange();
    runEmulation();
}

// ===== Playback =====
function scrubTo(val) {
    const count = parseInt(val);
    updateCharts(count);
    updateStats(count);
    updateStepLog(count);
    const timeMs = count > 0 ? cumTime[count - 1].toFixed(1) : '0.0';
    document.getElementById('scrub-info').textContent = `I/O ${count} / ${currentTrace.length} | ${timeMs} / ${totalTime_ms.toFixed(1)} ms`;
}

function togglePlay() {
    if (playing) stopPlay(); else startPlay();
}

function startPlay() {
    playing = true;
    document.getElementById('btn-play').textContent = '\u23F8 Pause';
    let idx = parseInt(document.getElementById('scrubber').value);
    if (idx >= currentTrace.length) idx = 0;
    playTick(idx);
}

function playTick(idx) {
    if (!playing || idx >= currentTrace.length) {
        scrubTo(idx);
        stopPlay();
        return;
    }
    idx = Math.min(idx + PLAY_STEP, currentTrace.length);
    document.getElementById('scrubber').value = idx;
    updateCharts(idx);
    const timeMs = idx > 0 ? cumTime[idx - 1].toFixed(1) : '0.0';
    document.getElementById('scrub-info').textContent = `I/O ${idx} / ${currentTrace.length} | ${timeMs} / ${totalTime_ms.toFixed(1)} ms`;
    if (idx % (PLAY_STEP * 15) === 0 || idx >= currentTrace.length) {
        updateStats(idx);
        updateStepLog(idx);
    }
    playTimer = setTimeout(() => playTick(idx), PLAY_INTERVAL);
}

function stopPlay() {
    playing = false;
    document.getElementById('btn-play').textContent = '\u25B6 Play';
    if (playTimer) { clearTimeout(playTimer); playTimer = null; }
}

// ===== Init =====
createCharts();
onEpochAutoChange();
runEmulation();
</script>
</body>
</html>
